"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _core = require("@emotion/core");

var _styledComponentVariant = _interopRequireDefault(require("styled-component-variant"));

var getValue = function getValue(props, val) {
  return typeof val === 'function' ? val(props) : val;
};

var createMediaQuery = function createMediaQuery(n, styles, reset) {
  return (
    /*#__PURE__*/
    (0, _core.css)("@media screen and (min-width:", n, "){", reset, ";", styles, ";}")
  );
};

var _default = function _default(prop, values) {
  return function (props) {
    if (!(prop in props)) return undefined;
    var propValue = props[prop];
    if (typeof propValue === 'string') return (0, _styledComponentVariant["default"])(prop, values)(props);
    var base = propValue && propValue.base;
    if (!base) throw new Error('Argument Error: A base variant must be provided when using responsive props.');
    var _props$theme = props.theme;
    _props$theme = _props$theme === void 0 ? {
      breakpoints: undefined
    } : _props$theme;
    var breakpoints = _props$theme.breakpoints;
    if (!breakpoints) throw new Error('Argument Error: breakpoints must be provided when variant is an Array.');
    var responsive = Object.keys(breakpoints).reduce(function (styles, breakpointName) {
      var variantName = propValue[breakpointName];
      if (!variantName) return styles;
      return [].concat((0, _toConsumableArray2["default"])(styles), [createMediaQuery(breakpoints[breakpointName], getValue(props, values[variantName]), getValue(props, values.reset))]);
    }, []);
    return (
      /*#__PURE__*/
      (0, _core.css)(getValue(props, values[base]), ";", responsive, ";")
    );
  };
};

exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdHlsZXMvcmVzcG9uc2l2ZS50cyJdLCJuYW1lcyI6WyJnZXRWYWx1ZSIsInByb3BzIiwidmFsIiwiY3JlYXRlTWVkaWFRdWVyeSIsIm4iLCJzdHlsZXMiLCJyZXNldCIsImNzcyIsInByb3AiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJwcm9wVmFsdWUiLCJiYXNlIiwiRXJyb3IiLCJ0aGVtZSIsImJyZWFrcG9pbnRzIiwicmVzcG9uc2l2ZSIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJicmVha3BvaW50TmFtZSIsInZhcmlhbnROYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUVBLElBQU1BLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQUNDLEtBQUQsRUFBUUMsR0FBUjtBQUFBLFNBQWlCLE9BQU9BLEdBQVAsS0FBZSxVQUFmLEdBQTRCQSxHQUFHLENBQUNELEtBQUQsQ0FBL0IsR0FBeUNDLEdBQTFEO0FBQUEsQ0FBakI7O0FBQ0EsSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFDQyxDQUFELEVBQUlDLE1BQUosRUFBWUMsS0FBWjtBQUFBO0FBQUE7QUFBQSxRQUFzQkMsU0FBdEIsbUNBQ1NILENBRFQsUUFFbkJFLEtBRm1CLE9BR25CRCxNQUhtQjtBQUFBO0FBQUEsQ0FBekI7O2VBT2Usa0JBQUNHLElBQUQsRUFBT0MsTUFBUDtBQUFBLFNBQWtCLFVBQUFSLEtBQUssRUFBSTtBQUN4QyxRQUFJLEVBQUVPLElBQUksSUFBSVAsS0FBVixDQUFKLEVBQXNCLE9BQU9TLFNBQVA7QUFFdEIsUUFBTUMsU0FBUyxHQUFHVixLQUFLLENBQUNPLElBQUQsQ0FBdkI7QUFFQSxRQUFJLE9BQU9HLFNBQVAsS0FBcUIsUUFBekIsRUFBbUMsT0FBTyx3Q0FBUUgsSUFBUixFQUFjQyxNQUFkLEVBQXNCUixLQUF0QixDQUFQO0FBRW5DLFFBQU1XLElBQUksR0FBR0QsU0FBUyxJQUFJQSxTQUFTLENBQUNDLElBQXBDO0FBRUEsUUFBSSxDQUFDQSxJQUFMLEVBQ0UsTUFBTSxJQUFJQyxLQUFKLENBQVUsOEVBQVYsQ0FBTjtBQVZzQyx1QkFZa0JaLEtBWmxCLENBWWpDYSxLQVppQztBQUFBLDZDQVlWO0FBQUNDLE1BQUFBLFdBQVcsRUFBRUw7QUFBZCxLQVpVO0FBQUEsUUFZekJLLFdBWnlCLGdCQVl6QkEsV0FaeUI7QUFjeEMsUUFBSSxDQUFDQSxXQUFMLEVBQ0UsTUFBTSxJQUFJRixLQUFKLENBQVUsd0VBQVYsQ0FBTjtBQUVGLFFBQU1HLFVBQVUsR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlILFdBQVosRUFBeUJJLE1BQXpCLENBQWdDLFVBQUNkLE1BQUQsRUFBU2UsY0FBVCxFQUE0QjtBQUM3RSxVQUFNQyxXQUFXLEdBQUdWLFNBQVMsQ0FBQ1MsY0FBRCxDQUE3QjtBQUVBLFVBQUksQ0FBQ0MsV0FBTCxFQUFrQixPQUFPaEIsTUFBUDtBQUVsQiwyREFDS0EsTUFETCxJQUVFRixnQkFBZ0IsQ0FDZFksV0FBVyxDQUFDSyxjQUFELENBREcsRUFFZHBCLFFBQVEsQ0FBQ0MsS0FBRCxFQUFRUSxNQUFNLENBQUNZLFdBQUQsQ0FBZCxDQUZNLEVBR2RyQixRQUFRLENBQUNDLEtBQUQsRUFBUVEsTUFBTSxDQUFDSCxLQUFmLENBSE0sQ0FGbEI7QUFRRCxLQWJrQixFQWFoQixFQWJnQixDQUFuQjtBQWVBO0FBQUE7QUFBQSxVQUFPQyxTQUFQLEVBQ0lQLFFBQVEsQ0FBQ0MsS0FBRCxFQUFRUSxNQUFNLENBQUNHLElBQUQsQ0FBZCxDQURaLE9BRUlJLFVBRko7QUFBQTtBQUlELEdBcENjO0FBQUEsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3NzfSBmcm9tICdAZW1vdGlvbi9jb3JlJztcbmltcG9ydCB2YXJpYW50IGZyb20gJ3N0eWxlZC1jb21wb25lbnQtdmFyaWFudCc7XG5cbmNvbnN0IGdldFZhbHVlID0gKHByb3BzLCB2YWwpID0+ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsKHByb3BzKSA6IHZhbCk7XG5jb25zdCBjcmVhdGVNZWRpYVF1ZXJ5ID0gKG4sIHN0eWxlcywgcmVzZXQpID0+IGNzc2BcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogJHtufSkge1xuICAgICR7cmVzZXR9O1xuICAgICR7c3R5bGVzfTtcbiAgfVxuYDtcblxuZXhwb3J0IGRlZmF1bHQgKHByb3AsIHZhbHVlcykgPT4gcHJvcHMgPT4ge1xuICBpZiAoIShwcm9wIGluIHByb3BzKSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wc1twcm9wXTtcblxuICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiB2YXJpYW50KHByb3AsIHZhbHVlcykocHJvcHMpO1xuXG4gIGNvbnN0IGJhc2UgPSBwcm9wVmFsdWUgJiYgcHJvcFZhbHVlLmJhc2U7XG5cbiAgaWYgKCFiYXNlKVxuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgRXJyb3I6IEEgYmFzZSB2YXJpYW50IG11c3QgYmUgcHJvdmlkZWQgd2hlbiB1c2luZyByZXNwb25zaXZlIHByb3BzLicpO1xuXG4gIGNvbnN0IHt0aGVtZToge2JyZWFrcG9pbnRzfSA9IHticmVha3BvaW50czogdW5kZWZpbmVkfX0gPSBwcm9wcztcblxuICBpZiAoIWJyZWFrcG9pbnRzKVxuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgRXJyb3I6IGJyZWFrcG9pbnRzIG11c3QgYmUgcHJvdmlkZWQgd2hlbiB2YXJpYW50IGlzIGFuIEFycmF5LicpO1xuXG4gIGNvbnN0IHJlc3BvbnNpdmUgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cykucmVkdWNlKChzdHlsZXMsIGJyZWFrcG9pbnROYW1lKSA9PiB7XG4gICAgY29uc3QgdmFyaWFudE5hbWUgPSBwcm9wVmFsdWVbYnJlYWtwb2ludE5hbWVdO1xuXG4gICAgaWYgKCF2YXJpYW50TmFtZSkgcmV0dXJuIHN0eWxlcztcblxuICAgIHJldHVybiBbXG4gICAgICAuLi5zdHlsZXMsXG4gICAgICBjcmVhdGVNZWRpYVF1ZXJ5KFxuICAgICAgICBicmVha3BvaW50c1ticmVha3BvaW50TmFtZV0sXG4gICAgICAgIGdldFZhbHVlKHByb3BzLCB2YWx1ZXNbdmFyaWFudE5hbWVdKSxcbiAgICAgICAgZ2V0VmFsdWUocHJvcHMsIHZhbHVlcy5yZXNldClcbiAgICAgICksXG4gICAgXTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBjc3NgXG4gICAgJHtnZXRWYWx1ZShwcm9wcywgdmFsdWVzW2Jhc2VdKX07XG4gICAgJHtyZXNwb25zaXZlfTtcbiAgYDtcbn07XG4iXX0=